# IMPORTS:

import pywt

# CONSTANTS:

WAVELET = "haar"
ALPHA = .99
BETA = .01

assert ALPHA > BETA

# UTILITIES:

product = reduce$((*))

transform = pywt.dwt2$(wavelet=WAVELET)

inv_transform = pywt.idwt2$(wavelet=WAVELET)

def trans_shape(image):
    return (image.shape[0]+1)//2, (image.shape[1]+1)//2

def fuse(a, b):
    out = (a*ALPHA + b*BETA)/(ALPHA + BETA)
    return out |> round |> int

def unfuse(a, out):
    b = (out*(ALPHA + BETA) - a*ALPHA)/BETA
    return b |> round |> int

def encode(cover_image, secret_image):
    assert cover_image.ndim == 2
    assert secret_image.ndim == 2
    shape1 = trans_shape(cover_image)
    a1, (h1, v1, d1) = transform(cover_image)
    shape2 = trans_shape(secret_image)
    a2, (h2, v2, d2) = transform(secret_image)
    for x in range(0, shape1[0]):
        for y in range(0, shape1[1]):
            if x < shape2[0] and y < shape2[1]:
                a1[x, y] |>= fuse$(a2[x,y])
                h1[x, y] |>= fuse$(h2[x,y])
                v1[x, y] |>= fuse$(v2[x,y])
                d1[x, y] |>= fuse$(d2[x,y])
    return inv_transform((a1, (h1, v1, d1)))

def decode(encoded_image, cover_image):
    assert encoded_image.ndim == 2
    assert cover_image.ndim == 2
    assert encoded_image.shape == cover_image.shape
    shape = trans_shape(encoded_image)
    a1, (h1, v1, d1) = transform(encoded_image)
    a2, (h2, v2, d2) = transform(cover_image)
    for x in range(0, shape[0]):
        for y in range(0, shape[1]):
            a1[x, y] |>= unfuse$(a2[x,y])
            h1[x, y] |>= unfuse$(h2[x,y])
            v1[x, y] |>= unfuse$(v2[x,y])
            d1[x, y] |>= unfuse$(d2[x,y])
    return inv_transform((a1, (h1, v1, d1)))

# MAIN:

if __name__ == "__main__":
    from skimage import io, \data
    cover_image = \data.horse()
    secret_image = \data.coins()
    io.imshow(cover_image)
    encoded_image = encode(cover_image, secret_image)
    io.imshow(encoded_image)
    retrieved_image = decode(encoded_image, cover_image)
    io.imshow(retrieved_image)
    io.show()
